"""
SECUENCIA DE FIBONACCI

EXPLICACION:

- 1: INDICAR EL INICIO CON UNA LISTA, LA LISTA
DEBE TENER EN SU CONTENIDO EL 0 Y EL 1, NUMEROS NECESARIOS 
PARA INICIAR CON LA ESPIRAL.

- 2: EL SEGUNDO PASO ES INDICAR LA CANTIDAD DE ELEMENTOS QUE
SE ESPERA RECIBIR CON ESTA SECUENCIA.

- 3: EN MI CASO, DECIDI HACER LA SECUENCIA UTILIZANDO UN BUCLE
WHILE --> MIENTRAS I (CANTIDAD DE ELEMENTOS QUE TIENE LA LISTA)
NO SEA IGUAL A LA CANTIDAD DE ELEMENTOS QUE ESPERO QUE DEVUELVA
EL ALGORITMO (NUM), SE VA A REALIZAR LA ECUACION DEL SIGUIENTE PASO.

- 4: LA ECUACION QUE SE UTILIZA PARA ESTE ALGORITMO ES LA SIGUIENTE:

[0 , 1]

LA LONGITUD DE ESTA LISTA ES DE 2 OBJETOS, CADA OBJETO LLEVA UN INDICE
QUE PUEDE SER USADO PARA ACCEDER A ESTOS OBJETOS.

TENIENDO EN CUENTA QUE EL TIPO DE DATO DE ESTOS ELEMENTOS ES INT(ENTERO), QUE EN
LA SECUENCIA DE FIBONACCI CADA TERMINO SUCESIVO ES LA SUMA DE LOS DOS TERMINOS ANTERIORES
Y QUE PARA ACCEDER A UNA LISTA SE UTILIZA UN INDICE QUE EMPIEZA EN CERO,
PODEMOS REALIZAR LA SIGUIENTE CONCLUSION:

LONGITUD DE LA LISTA - 1 == INDICE DEL ULTIMO ELEMENTO
LONGITUD DE LA LISTA - 2 == INDICE DEL ANTE ULTIMO ELEMENTO

POR LO QUE LA ECUACION DEL TERMINO SIGUIENTE ES LA SUMA DE ESTOS DOS INDICES.

- 5: LA COMPROBACION DE QUE LA LONGITUD DE LA LISTA SEA LA DESEADA ES REALIZADA AUTOMATICAMENTE
HASTA QUE SEA VERDADERA LA RESPUESTA Y EL BUCLE SE DETENGA!.


JZ9 DEV

"""

print("JZ9 FIBONACCI")

fb = [0,1]
i = len(fb)

def __main__(fb, i):
    try:
        num = int(input("Quantity: "))
    except:
        print("Insert a number!")
        return __main__(fb, i)
    
    while i+1 != int(num):
        i = len(fb)
        f = fb[i-1] + fb[i-2]
        fb.append(f)
    print(fb)
    return __main__(fb, i)

__main__(fb, i)
